# CPU Algorithms Simulation

The **CPU Algorithms Simulation** project pairs a Java-based scheduling API with a React interface to showcase classic CPU scheduling strategies: First-Come-First-Served (FCFS), Shortest Remaining Time First (SRTF), Round Robin (RR), and Non-preemptive Priority (NPP). The React UI now operates strictly as a frontend client, delegating all scheduling work to the Java backend.

## Tech Stack

- **Java 11+** using `com.sun.net.httpserver.HttpServer` for the REST API.
- **React 18** with Vite for the client UI.
- **Node.js 18+** for frontend tooling.

## Prerequisites

Make sure the following are available on your workstation:

1. Java Development Kit (JDK) 11 or newer.
2. Node.js 18 or newer (includes npm).
3. Git (optional) for cloning the repository.

## Running the Backend API (Java)

1. From the project root, compile the Java sources:
   ```bash
   javac -d out $(find src -name "*.java")
   ```
2. Start the HTTP server (defaults to port `8080`):
   ```bash
   java -cp out main.Main
   ```
   - Pass a custom port as the first argument if needed, e.g. `java -cp out main.Main 9090`.
   - The API becomes available at `http://localhost:<port>/api/schedule`.

### API Contract

- **Endpoint:** `POST /api/schedule`
- **Request body:**
  ```json
  {
    "algorithm": "RR",
    "timeQuantum": 2,
    "processes": [
      { "pid": 1, "arrivalTime": 0, "burstTime": 5, "priority": 1 },
      { "pid": 2, "arrivalTime": 2, "burstTime": 3, "priority": 2 }
    ]
  }
  ```
  - `timeQuantum` is required for Round Robin; ignored otherwise.
- **Response body:**
  ```json
  {
    "processes": [
      {
        "pid": 1,
        "arrivalTime": 0,
        "burstTime": 5,
        "priority": 1,
        "waitingTime": 3,
        "turnaroundTime": 8,
        "startTime": 0,
        "completionTime": 8
      }
    ],
    "averageWaitingTime": 1.5,
    "averageTurnaroundTime": 6.0
  }
  ```

All responses include CORS headers (`Access-Control-Allow-Origin: *`) to support local frontend development. Error payloads follow the shape `{ "error": "message" }`.

## Running the Frontend (React)

1. Install dependencies:
   ```bash
   cd gui
   npm install
   ```
2. Provide the backend URL if it differs from the default by creating `.env` in `gui/`:
   ```bash
   echo "VITE_API_BASE_URL=http://localhost:8080" > .env
   ```
   - The default base URL is `http://localhost:8080` when `.env` is omitted.
3. Start the Vite development server:
   ```bash
   npm run dev
   ```
4. Open the printed URL (typically `http://localhost:5173`).
5. Add processes, select an algorithm, and click **Run**. The UI will display loading and error states while it awaits the API response.

## Frontend Highlights

- Process chips support inline removal and re-index automatically.
- Results display sorts by PID and shows averages supplied by the backend.
- Error feedback surfaces validation issues returned by the API (e.g., missing burst time, invalid quantum).

## Project Structure

```
CPU-Algorithms-Simulation/
├── .vscode/                # Editor settings (Java source path, etc.)
├── gui/                    # React + Vite frontend
│   ├── public/
│   └── src/
│       ├── App.jsx         # Top-level React component
│       ├── components/     # UI building blocks (ProcessInput, ResultsDisplay)
│       ├── styles/         # Global CSS + modules
│       ├── types/          # Frontend process helpers
│       └── utils/          # API client and algorithm metadata
├── out/                    # Compiled Java classes (generated by javac)
└── src/
  └── main/               # Java backend sources
    ├── Main.java       # REST API entry point
    ├── Process.java    # Process model
    ├── Scheduler.java  # Scheduler contract
    ├── SchedulerFactory.java # Scheduler resolver
    ├── algorithms/     # FCFS, SRTF, RR, NPP implementations
    └── http/           # JSON helper + HTTP handler
```

## Extending the System

- **New algorithm:** Implement `Scheduler`, place it under `src/main/algorithms`, and extend `SchedulerFactory` plus the frontend `ALGORITHMS` map.
- **Additional metrics:** Compute new stats in `ScheduleHandler.buildResponse` and surface them in the React UI.
- **Deployment:** Wrap the Java server in a build tool (Maven/Gradle) or container for easier distribution, and configure Vite to proxy API requests in production builds.

## Troubleshooting

- **Backend compile errors:** Confirm you are compiling with JDK 11+ and that the `out` directory exists (created automatically by the `javac` command above).
- **Port conflicts:** Supply a free port via `java -cp out main.Main 9000` and update `VITE_API_BASE_URL` accordingly.
- **CORS issues:** Ensure the React app targets the correct base URL; the backend already exposes permissive CORS headers for development.
- **Frontend build failures:** Verify Node.js 18+ and reinstall dependencies with `npm install`.

## Contributors

- Apilado, Jabez Timothy E. — Back-end lead and CLI implementation
- Maninang, Allein Dane G. — Scheduling algorithms (back end)
- Parungao, Nikko S. — Scheduling algorithms (back end)
- Gurango, Christine Francoise O. — React interface (front end)
- Quilantang, Grant Mihkael D. — React interface (front end)

## References

- **Backend**
	- GeeksforGeeks. (2020, March 18). FCFS First Come First Serve CPU Scheduling. GeeksforGeeks. [geeksforgeeks.org/dsa/first-come-first-serve-cpu-scheduling-non-preemptive](https://www.geeksforgeeks.org/dsa/first-come-first-serve-cpu-scheduling-non-preemptive/)
	- GeeksforGeeks. (2025, January 13). Priority Scheduling in Operating System. GeeksforGeeks. [geeksforgeeks.org/operating-systems/priority-scheduling-in-operating-system](https://www.geeksforgeeks.org/operating-systems/priority-scheduling-in-operating-system/)
	- GeeksforGeeks. (2026, January 5). Shortest remaining time first (Preemptive SJF) scheduling algorithm. GeeksforGeeks. [geeksforgeeks.org/dsa/shortest-remaining-time-first-preemptive-sjf-scheduling-algorithm](https://www.geeksforgeeks.org/dsa/shortest-remaining-time-first-preemptive-sjf-scheduling-algorithm/)
	- GeeksforGeeks. (2026b, January 6). Round Robin scheduling in operating system. GeeksforGeeks. [geeksforgeeks.org/operating-systems/round-robin-scheduling-in-operating-system](https://www.geeksforgeeks.org/operating-systems/round-robin-scheduling-in-operating-system/)
	- GeeksforGeeks. (2018, November 13). Preemptive and NonPreemptive Scheduling. GeeksforGeeks. [geeksforgeeks.org/operating-systems/preemptive-and-non-preemptive-scheduling](https://www.geeksforgeeks.org/operating-systems/preemptive-and-non-preemptive-scheduling/)
	- GeeksforGeeks. (2023, January 17). Spooling in Operating System. GeeksforGeeks. [geeksforgeeks.org/operating-systems/spooling-in-operating-system](https://www.geeksforgeeks.org/operating-systems/spooling-in-operating-system/)
	- Operating Systems: CPU Scheduling. (2026). Uic.edu. [cs.uic.edu/~jbell/CourseNotes/OperatingSystems/5_CPU_Scheduling.html](https://www.cs.uic.edu/~jbell/CourseNotes/OperatingSystems/5_CPU_Scheduling.html)
	- Short, M. (2010). The Case For Non-preemptive, Deadline-driven Scheduling In Real-time Embedded Systems. IAENG International Journal of Computer Science, 1(1). [researchgate.net/publication/45534417_The_Case_For_Non-preemptive_Deadline-driven_Scheduling_In_Real-time_Embedded_Systems](https://www.researchgate.net/publication/45534417_The_Case_For_Non-preemptive_Deadline-driven_Scheduling_In_Real-time_Embedded_Systems)
	- sched(7) - Linux manual page. (2026). Man7.org. [man7.org/linux/man-pages/man7/sched.7.html](https://man7.org/linux/man-pages/man7/sched.7.html)
	- CFS Scheduler — The Linux Kernel documentation. (n.d.). [docs.kernel.org/scheduler/sched-design-CFS.html](https://docs.kernel.org/scheduler/sched-design-CFS.html)
	- Harchol-Balter, M., Schroeder, B., Bansal, N., & Agrawal, M. (2003). Size-based scheduling to improve web performance. ACM Transactions on Computer Systems, 21(2), 207–233. [doi.org/10.1145/762483.762486](https://doi.org/10.1145/762483.762486)

- **Frontend**
	- DeepSeek. (n.d.). DeepSeek. [deepseek.com](https://www.deepseek.com/)
	- Vitejs. (n.d.). GitHub - vitejs/vite-plugin-react: The all-in-one Vite plugin for React projects. GitHub. [github.com/vitejs/vite-plugin-react](https://github.com/vitejs/vite-plugin-react)
	- Css-Modules. (n.d.). GitHub - css-modules/css-modules: Documentation about css-modules. GitHub. [github.com/css-modules/css-modules](https://github.com/css-modules/css-modules)
	- Using CSS custom properties (variables) - CSS | MDN. (2025, December 16). [developer.mozilla.org/en-US/docs/Web/CSS/Guides/Cascading_variables/Using_custom_properties](https://developer.mozilla.org/en-US/docs/Web/CSS/Guides/Cascading_variables/Using_custom_properties)

## License

This project is released for educational use. Apply additional licensing as needed before redistribution.
